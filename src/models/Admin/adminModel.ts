import { Schema, model } from 'mongoose';
import bcrypt from 'bcrypt';
import { AdminRoles, IAdmin, IAccountStatus } from '../../interfaces';
import { generatePassword } from '../../functions';
import { config } from '../../config';

const { ADMINS } = config.MONGO_COLLECTIONS;

interface IAdminDocument extends IAdmin {
  matchPasswords: (password: string) => boolean;
  changePassword: (password: string) => void;
  regeneratePassword: () => string;
  resetPassword: (password: string) => boolean;
  matchLastPasswords: (password: string) => boolean;
}

const adminSchema = new Schema<IAdminDocument>(
  {
    code: {
      type: String,
      required: false,
      unique: true,
    },
    name: {
      type: String,
      required: true,
    },
    username: {
      type: String,
      required: true,
      unique: true,
      lowercase: true,
      trim: true,
      minlength: 3,
      maxlength: 15,
    },
    password: {
      type: String,
      required: true,
      select: false,
    },
    email: {
      type: String,
      required: true,
      unique: true,
      lowercase: true,
      trim: true,
    },
    phone: {
      type: Number,
      required: true,
      maxlength: 10,
      unique: true,
    },
    role: {
      type: String,
      enum: AdminRoles,
      default: AdminRoles.ADMIN,
    },
    status: {
      type: String,
      required: true,
      enum: IAccountStatus,
      default: IAccountStatus.ACTIVE,
    },
    autoGeneratedPasswd: {
      type: Boolean,
      default: false,
      select: false,
    },
    resetPasswordAccess: {
      type: Boolean,
      default: false,
      select: false,
    },
    lastPassword: {
      type: String,
      select: false,
    },
    passwordChanged: {
      type: Boolean,
      default: false,
    },
    passwordChangedAt: {
      type: Date,
    },
    lastUsed: {
      type: Date,
      default: new Date(),
    },
    lastSync: {
      type: Date,
      default: new Date(),
    },
    usedIPaddress: [
      {
        type: String,
      },
    ],
    isDeleted: {
      type: Boolean,
      default: false,
    },
    deletedAt: {
      type: Date,
      default: undefined,
    },
  },
  { timestamps: true }
);

adminSchema.pre('save', async function (next) {
  if (this.isModified('password')) {
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
  }
  if (this.isNew) {
    const lastCodeDoc = await Admin.findOne({}, { code: 1 }).sort({
      createdAt: -1,
    });

    if (lastCodeDoc) {
      const lastNumber = parseInt(lastCodeDoc.code.slice(3));
      this.code = `ADN${lastNumber + 1}`;
    } else {
      this.code = 'ADN100';
    }
  }
  next();
});

adminSchema.methods.matchPasswords = async function (password: string) {
  return await bcrypt.compare(password, this.password);
};

adminSchema.methods.regeneratePassword = async function () {
  this.lastPassword = this.password;
  const newPassword = await generatePassword();
  this.generatePassword = true;
  this.password = newPassword;
  this.passwordChanged = true;
  this.passwordChangedAt = new Date();
  await this.save();
  return newPassword;
};

adminSchema.methods.resetPassword = async function (password: string) {
  if (this.resetPasswordAccess) {
    this.lastPassword = this.password;
    this.password = password;
    this.passwordChanged = true;
    this.passwordChangedAt = new Date();
    await this.save();
    return true;
  }
  return false;
};

adminSchema.methods.changePassword = async function async(password: string) {
  if (this.autoGeneratedPasswd) this.autoGeneratedPasswd = false;
  this.lastPassword = this.password;
  this.password = password;
  this.passwordChanged = true;
  this.passwordChangedAt = new Date();
  await this.save();
};

adminSchema.methods.matchLastPasswords = async function (password: string) {
  return await bcrypt.compare(password, this.lastPassword);
};

const Admin = model(ADMINS, adminSchema);

export default Admin;
